\documentclass[10pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\title{Thesis Proposal, \\PhD Fellowship Program 2014}
\author{Niki Vazou}
\date{}
\begin{document}
\maketitle
%%%%%%% 
MOTIVATION - GOAL
My research is type-based verification of Haskell programs 
and aims to create a sound and usable verifier that can be
embedded into a real haskell compiler.

** type-based verification
Type-based verification pushes the advantages of types to limits.
Among the advantages of type systems is that they enforce code documentation and soundness, by providing interface for functions and catching run time errors.

* Catching run time errors
Consider a division operator. Its type 
div :: Int -> Int -> Int
defines its structure: it is a function that given two integers it will create an integer.
%
So, division by a real number (div 4 3.14) will create type error notifying the user the operator is not used correctly, thus catching a potential run time error 
But, division by zero (div 4  0) will type-check even though it will lead to a run time error.

We use refinement types to refine div's type and specify that the divisor should be proven to be different than zero: 
div :: Int -> {v:Int | v!=0} -> Int
Thus now, division by zero (div 4 0) will not only statically catch the 
error, but also, specify the code that created it.

* Documentation
Consider a library implementing heap of values `a`.
In the library there must be a pop function with type
pop :: Heap a -> (a, Heap a)
Much of pop's functionality is described by its type:
pop takes a heap and returns one of its elements and the updated heap.
What is important is that pop's type is exported, but not its implementation, 
thus the maintainer of the library can modify pop's implementation  as long as the interface ie., its type, remains unchanged.


We use refinement types to enhance the information captured by types.
As an example, 
popMax :: Heap a -> (x:a, Heap {v:a | v >= x})
describes a function that given a heap returns the maximum element of this heap and as before the implementor of a verified heap library 
should "prove" that any implementation of the function satisfies its exposed type; after which the use can rely on it.


%Conclusion
Since languages that rely on type-systems (like Haskell and ML) 
are greatly used by both research and industry this projects aims 
at enhancing the expressiveness of types 
so that uses can talk not only about the structure, but also about properties of their code.  



** Haskell
The choice of Haskell as a target language for this project is not random, as its features have render haskell as a promising language.
Specifically, its expressive type system lead haskell programmers to write documented and  correct programs; the fact that it is a pure language, makes haskell an ideal target for concurrent execution and finally, features such as laziness and sharing lead to high performance. 
Most importantly, haskell has be seen to work as a prototype for mainstream languages,
hence, by targeting haskell we aim to build a next generation verification system that can hopefully be integrated to other languages.



** Usability

A key feature of this project is to make verification of haskell source code, easy to use.
Haskell already supports verification via dependent types, but their usage requires that the user
(1) modifies the existing code by lifting expressions to types
and (2) explicitly provide proofs as generally type checking with dependent types is undecidable.
Both these features render verification with dependent types cumbersome [hazohism].
%
Refinement types provide an easier to use approach as minimum code modifications are required 
and the proofs are inferred using an SMT solver..
%
A refinement type is just a haskell type where each basic type `a` can be annotated as 
{v:a | p} representing the set of values that are of type `a` and moreover satisfy the predicate p.
With this, existing haskell code can be verified with minimum modifications.
% 
Type checking of refinements is decidable and proofs are automatically created using SMT solvers (as z3) which provides advantage, as the increasing interest on SMT solvers allows fast type checking.

All in all, the goal of this project is using the power of SMT solvers to 
create a next-generation type based verifier for Haskell and integrate it to ghc.
The project focuses on the simplicity of the specification:
the specification language is simple, as it is based on the existing type annotations
refined with logical predicates.
Moreover, the code modifications and annotations required for verification should be minor.
A long term goal will be to embed this type-based verification to mainstream languages.





%%%%%


%% CURRENT WORK

%% the tool
We have implemented liquidHaskell, a tool that takes as input
a target Haskell source file, with the desired refinement types specified as a special
form of comment annotation,
After analyzing the program, liquidHaskell returns as output:
-- Either SAFE, indicating that all the specifications indeed verify, or UNSAFE, indicating there are refinement type errors, together with the positions in the source
code where type checking fails (e.g., functions that do not satisfy their signatures,
or callsites where the inputs don't conform to the specifications).
-- An HTML file containing the program source code annotated with inferred refinement types for all sub-expressions in the program. The inferred refinement type for
each program expression is the strongest possible type over the given set of logical qualifiers. When a type error is reported,  it is highlighted with red color, and the programmer can use the inferred
types to determine why their program does not typecheck: they can examine what
properties liquidHaskell can deduce about various program expressions and 
provide stronger specification or alter the program as necessary so that it typechecks.

%% Specifications
The core of liquidHaskell performs liquid type inference and checking as described in [PLDI 2008].
Specifications are expressed using refinement types, ie. types annotated with predicates
As an example, type {v : Int | v > 0} describes a value v which is an integer and the refinements specifies that this value is greater than zero.
The language of the predicates, contains logical formulas, linear arithmetic and uninterpreted functions. Moreover, the user can define ``measures'' on haskell data types, for example, he can define a measure ``len'' that captures the length of a list and use it on the specifications 


%% what is new
When implementing liquid types for haskell we had to consider haskell-specific features that lead to unsoundeness,
specifically type class constraints and laziness.

% Type class constraints 
To keep both precision and soundness in the presence of type class constraints, 
we came up with Abstract Refinement Types that allows a type to be parameterized over its refinements.
As an example, we refine the type of a max function as

max :: forall a <p :: a -> Prop>. Ord a => {v:a | p v} -> {v:a | p v} -> {v:a | p v}
max x y = if x >= y then x else y

expressing that for any predicate p on values of type a 
if both inputs satisfy p then the output will satisfy p

It turns out that abstract refinement types greatly enhance the expressiveness of the system
without increasing its complexity.
We treat abstract refinements as uninterpreted function symbols, which are already supported 
by the logic. On the same time, they can be used to propagate properties of input to the output (as in the case of max),
to express recursive or index dependent invariants of data-types and to refine higher order functions.

% Laziness
In the presence of laziness traditional refinement systems become unsound.
This is because of the different (with respect to strict) treatment of infinite computations:

let x = non-terminating
in     ... assert (false) ...

In a strict language, computation will get stuck while evaluating x, 
after which every assertion, even the contradiction false, can be verified.

In a lazy setting, a thunk will be created for x and computation will proceed, 
thus the above assertion should be marked as unsafe.

Verification of the strict alternative is achieved because the refinement type of the
no-terminating computation carries some information that allows the system to prove any 
forthcoming assertion.

To address the unsoundness in the lazy setting we choose to ignore the information carried 
by any potentially non-terminating computation.

To do so, we need a mechanism to identify all such computations.
It is straightforward to extend refinement types to support a size based termination analysis.

This approach has both advantages and disadvantages.
One one hand, we ignore all information carried by non-terminating computations.
even the meaningful ones.

On the other, we regain soundness under lazy evaluation, and 
liquidHaskell can be used for termination analysis.

%% benchmarks
We used liquidHaskell to verify safety and functional correctness properties of the following Haskell libraries.
-- GHC.List, which implements many standard Prelude list
operations; we verify various size related properties,
-- Data.Set.Splay, which implements a set data type; 
we verify that all interface functions return well ordered trees,
-- Data.Map.Base, which implements a functional map data
type; we verify that all interface functions return
binary-search trees,
-- Bytestring, a library for manipulating byte arrays, we ver-
ify size-based low-level memory safety and high-level func-
tional correctness properties, and
-- Text, a library for high-performance unicode text process-
ing; we verify various pointer safety and functional correctness
properties, during which we find a subtle bug.

These libraries sum up to 8706 lines of code and require 
which require 1750 lines of annotation.
Moreover, verification time scales
with respect to both the number of lines 
and the complexity of the specifications
averaging about 1 sec for 8 lines of code..


%% FUTURE WORK
The goal of this project is to create a sound and usable verifier
for real world haskell applications that can be embedded to an
existing haskell compiler.
Many concrete subgoals exist towards this direction:

Soundness:
 
* Give formal semantics of liquidHaskell.
  Even though the semantics of a core calculus exist, 
  defining the formal semantics of the core language 
  will be an interesting venture
  that would potentially release hidden sources of unsoundness.


* As discussed earlier, in the presence of laziness, liquidHaskell's soundeness
  depends on a termination-checker.We would like to raise this dependency, 
  by allowing refinement types to carry information of non-termination.
  A direct approach is to alter the meaning of a refinement type e:{v:a | p}
  to if computation of e terminates, then the result satisfies p.
  Though sound, this information is too general to lead to precise results.
  But, using the termination checker we can have types 
  `e:{v:a | | p}`
  stating that the computation of e does terminate and the result satisfy p

Usability:

* Currently, typechecking is performed in granularity of module (haskell file)
  as the type of each function depends on its call sites.
  We want to rainse this dependence and get both modularity and speedup, as 
  then we can parallelize typechecking of many functions.
  Moreover, we will get incremental type checking: when a user edits a function, 
  only this function need to be rechecked.

* Multiple types 
  In liquidHaskell, currently, each expression has a unique type.
  Many times, we want to use different types on different occurrences of the same expression.
  thus support of conjunction types seems inevitable.

* Automate measures/inlining
  From our experience we saw that when verifying a code some procedures are standard.
  For example, when defining a  new data type we need to describe some properties like its size information.
  or many times, to enable verification we need to inline some higher order functions.
  All these procedures can be performed automatically.

* Abstract refinement inference
  As noted earlier liquid haskell supports abstract refinements to parameterize function types.
  It would be useful if abstract refinement types can be infered. 
  It seems though, that blindly trying to parameterize each type will be too expensive, 
  thus some heuristics should be used.


* Tutorial:
  Currently the tool can be found online combined with a number of examples, 
  and blog posts on how to use it.
  Since this is a work in progress many of its features are added or modified.
  It would be nice to construct and maintain a up-to-date document 
  that combines both how to use liquidHaskell and our experience so far in using the tool. 

* Error reporting.
  Currently, liquidHaskell reports only the location of that can not be proven to satisfy the specifications.
  It turns out that then the user needs to perform some reasoning, most of which is already performed 
  by the tool. Thus, using ideas from Abduction [Isil] we would like to expose some of these information
  and interactively help the user identify the source of the error.


Real-world Applications
* More real world benchmarks to investigate if security properties from web applications
  or concurency conditions can be expressed in the current refinement language.


* Haskell idiomatic code: 
  We would like to investigate how liquidHaskell performs when verifying haskell idiomatic 
  code that depends on type classes(express measures), monads (express invariants on monads)
  or infinite structures (currently we can not even refine) 


Integration to real compiler
 Integration to a real compiler can be interprented on two ways.
 The "straingforward" one is to al 
* Pattern Match Errors
  It turns out that by giving the appropriate types to internal ghc functions, refinement type errors can be created
 

* Interaction with haskell's dependent types
  Haskell already supports dependent types. While being very expressive, One of the burdens of which is that the user should
explicitly provide proofs.
  A nice research direction is to investigate if we can take advantage of their expressiveness, while asking liquidHaskell to
  automatically create proofs.



\end{document}