\subsection*{Motivation}

My research is type-based verification of Haskell programs 
and aims to create a sound and usable verifier that can be
embedded into a real haskell compiler.

\textbf{Type-based verification} pushes the advantages of types to limits.
Among the advantages of type systems is that they enforce code documentation and soundness, by providing interface for functions and catching run time errors.

* Catching run time errors
Consider a division operator. Its type 
div :: Int -> Int -> Int
defines its structure: it is a function that given two integers it will create an integer.
%
So, division by a real number (div 4 3.14) will create type error notifying the user the operator is not used correctly, thus catching a potential run time error 
But, division by zero (div 4  0) will type-check even though it will lead to a run time error.

We use refinement types to refine div's type and specify that the divisor should be proven to be different than zero: 
div :: Int -> {v:Int | v!=0} -> Int
Thus now, division by zero (div 4 0) will not only statically catch the 
error, but also, specify the code that created it.

* Documentation
Consider a library implementing heap of values `a`.
In the library there must be a pop function with type
pop :: Heap a -> (a, Heap a)
Much of pop's functionality is described by its type:
pop takes a heap and returns one of its elements and the updated heap.
What is important is that pop's type is exported, but not its implementation, 
thus the maintainer of the library can modify pop's implementation  as long as the interface ie., its type, remains unchanged.


We use refinement types to enhance the information captured by types.
As an example, 
popMax :: Heap a -> (x:a, Heap {v:a | v >= x})
describes a function that given a heap returns the maximum element of this heap and as before the implementor of a verified heap library 
should "prove" that any implementation of the function satisfies its exposed type; after which the use can rely on it.


%Conclusion
Since languages that rely on type-systems (like Haskell and ML) 
are greatly used by both research and industry this projects aims 
at enhancing the expressiveness of types 
so that uses can talk not only about the structure, but also about properties of their code.  



\textbf{Haskell:}
The choice of Haskell as a target language for this project is not random, as its features have render haskell as a promising language.
Specifically, its expressive type system lead haskell programmers to write documented and  correct programs; the fact that it is a pure language, makes haskell an ideal target for concurrent execution and finally, features such as laziness and sharing lead to high performance. 
Most importantly, haskell has be seen to work as a prototype for mainstream languages,
hence, by targeting haskell we aim to build a next generation verification system that can hopefully be integrated to other languages.



\textbf{Usability:}
A key feature of this project is to make verification of haskell source code, easy to use.
Haskell already supports verification via dependent types, but their usage requires that the user
(1) modifies the existing code by lifting expressions to types
and (2) explicitly provide proofs as generally type checking with dependent types is undecidable.
Both these features render verification with dependent types cumbersome [hazohism].
%
Refinement types provide an easier to use approach as minimum code modifications are required 
and the proofs are inferred using an SMT solver..
%
A refinement type is just a haskell type where each basic type `a` can be annotated as 
{v:a | p} representing the set of values that are of type `a` and moreover satisfy the predicate p.
With this, existing haskell code can be verified with minimum modifications.
% 
Type checking of refinements is decidable and proofs are automatically created using SMT solvers (as z3) which provides advantage, as the increasing interest on SMT solvers allows fast type checking.
\\

All in all, the goal of this project is using the power of SMT solvers to 
create a next-generation type based verifier for Haskell and integrate it to ghc.
The project focuses on the simplicity of the specification:
the specification language is simple, as it is based on the existing type annotations
refined with logical predicates.
Moreover, the code modifications and annotations required for verification should be minor.
A long term goal will be to embed this type-based verification to mainstream languages.




